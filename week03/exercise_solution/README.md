# Exercises Week 3 - Expected Observations for the Tracer Assignment

## Output of Tracer
* An extended `main()` might look like this for better segmentation of the output:

```cpp
int main() {
  std::cout << "--- Tracer m { \"main\" }; ---\n";
  Tracer m{"main"};
  {
    std::cout << "--- Tracer inner { \"inner\" }; ---\n";
    Tracer inner{"inner"};
    std::cout << "--- foo(inner); ---\n";
    foo(inner);
    std::cout << "--- auto trace = bar(inner); ---\n";
    auto trace = bar(inner);
    std::cout << "--- trace.show(); ---\n";
    trace.show();
    std::cout << "--- inner.show(); ---\n";
    inner.show();
    std::cout << "--- } of compound statement ---\n";
  }
  std::cout << "--- foo(Tracer{\"temp\"}); ---\n";
  foo(Tracer{"temp"});
  std::cout << "--- m.show(); ---\n";
  m.show();
  std::cout << "--- } of main() ---\n";
}
```

The observed output should look as follows:
```cpp
--- Tracer m { "main" }; ---
Tracer created: main //(1)
--- Tracer inner { "inner" }; ---
Tracer created: inner //(2)
--- foo(inner); ---
Tracer copied: inner copy //(3)
Tracer created: foo //(4)
Tracer: inner copy //(5)
Tracer destroyed: foo //(6)
Tracer destroyed: inner copy //(7)
--- auto trace = bar(inner); ---
Tracer created: bar //(8)
Tracer: inner //(9)
--- trace.show(); ---
Tracer: bar //(10)
--- inner.show(); ---
Tracer: inner //(11)
--- } of compound statement ---
Tracer destroyed: bar //(12)
Tracer destroyed: inner //(13)
--- foo(Tracer{"temp"}); ---
Tracer created: temp //(14)
Tracer created: foo //(15)
Tracer: temp //(16)
Tracer destroyed: foo //(17)
Tracer destroyed: temp //(18)
--- m.show(); ---
Tracer: main //(19)
--- } of main() ---
Tracer destroyed: main (20)
```

Explanations:
1. `Tracer` with argument `"main"` gets created. It will live until the end of its block.
2. `Tracer` with argument `"inner"` gets created. It will live until the end of its block.
3. A copy of the `inner` tracer is created for the `Tracer t` parameter of `foo`.
4. `Tracer` with argument `"foo"` gets created. It will live until the end of its block (the function `foo`).
5. Show for the `inner copy` Tracer is called.
6. End of `foo` the local objects get destroyed in reverse order. First the `foo` tracer.
7. Then the `inner copy` tracer
8. The `bar` call by itself does not generate any output. Therefore, the next out put is the creation of the `Tracer` with argument `"bar"`. This construction can happen at the location of the return value and directly initialze the `trace` variable in `main`. This is a combination of named return value optimization and mandatory elision of C++17. Subsequently, no destructor will be called at the end of `bar`.
9. Show for the original `inner` Tracer is called, from `bar()`.
10. Show for the `bar` Tracer (created in `bar()`) is called, by the call `tracer.show()].
11. Show for the original `inner` Tracer is called, from `main()`.
12. The local block ends at `}`, which ends the lifetime of the `trace` variable, which contains the `bar` Tracer.
13. The end of the block also ends the lifetime of the `inner` Tracer.
14. The `Tracer{"temp"}` prvalue is materialized when initializing the value parameter for `void foo(Tracer t)`.
15. Another `foo` Tracer is created, like above
16. Show for the `temp` materialized Tracer is called.
17. Destruction of the `foo` Tracer
18. Destruction of the `temp` Tracer
19. Show for the original `main` Tracer
20. Destuction of the original `main` Tracer, at end of `main()`.

## Tracer in Standard Container

### Observing the `push_back` Operations

At a glance, when checking the output of the four `push_back` operations there are more copies than expected. Especially, `T1` is copied several (three in my case) times. These copies happen when adding elements to a vector that has reached the capacity of the array used to store the elements. When this happens a new (bigger) array is allocated and all elements are copied to this new array. The old array is then deallocated.

Below is an excerpt from the output to show this behavior. It is generated by the `v.push_back(Tracer{"T2"})` statement.

```cpp
Tracer created: T2           (1)
Tracer copied: T2 copy       (2)
Tracer copied: T1 copy copy  (3)
Tracer destroyed: T1 copy    (4)
Tracer destroyed: T2         (5)
```

* Line 1: This is the output from constructing the temporary Tracer object.
* Line 2: In push_back the `T2` object is copied to the newly allocated storage array
* Line 3: The `T1` element, which is located in the old storage array is copied to the new storage array.
* Line 4: The old storage array is deallocated, which destorys the initial copy of `T1`.
* Line 5: This is the output of the destructor for the temporary Tracer object `T2`.

### Copying the vector
The result of copying the vector is straight-forward. Every element of the vector is copied again.

```
Tracer copied: T1 copy copy copy copy
Tracer copied: T2 copy copy copy
Tracer copied: T3 copy copy
Tracer copied: T4 copy copy
```

## Copy-Assignment

The implementation of the copy-assignment operator is as follows:

```
Tracer & operator=(Tracer const & rhs) {
  name = rhs.name + " copy-assigned";
  std::cout << "Tracer copy-assigned: " << name << std::endl;
  return *this;
}
```

* The code given for invoking the copy-assignment operator can be compiled successfully, as it is implicitly available on absence of a move-constructor and move-assignment operator. Remark: On a previous version of the exercise, which had an `std::ostream` reference as member variable, the situation would have been different. The implicit behavior of the copy-assignment operator would not have worked as an `std::ostream` is not copy-assignable. Thus preventing the default behavior of the copy-operation for the Tracer.
***Note:*** The existence of the implicit copy-assignment operator when there is a user-defined destructor or copy-constructor is flawed in the standard. As you can see on Howard Hinnant's overview in the lecture.
* An assignment operator always must be defined as member function.
* The effect of the explicitly implemented copy-assignment operator is straight-forward. `sink = source;` assigns the name of `source` to `sink` and adds the suffix `copy-assigned` to `sink`'s name. `source` remains unmodified.

## Move Operations

The copy-constructor and the copy-assignment operator are replaced by the following implementations of the move-constructor and the move-assignment operator:

```cpp
Tracer(Tracer && other) : name { other.name + " moved" } {
  other.name += " moved away";
  std::cout << "Tracer moved: " << name << std::endl;
}
Tracer & operator=(Tracer && other) {
  std::swap(name, other.name);
  name += " move-assigned";
  std::cout << "Tracer move-assigned: " << name << std::endl;
  other.name += " moved to";
  return *this;
}
```

* Because `Tracer` does not have its copy operations anymore, there needs to be three changes to the code of the `main` function at this point:
  * `foo(inner)` cannot be called anymore, as it requires a copy-operation to pass the parameter by value.
  * `std::vector<Tracer> v_copy { v };` also calls the non-existent copy constructor.
  * `sink = source` is an invalid assignment as `source` is an lvalue, but the move-assignment operator requires an rvalue. Furthermore, there neither is an implicit copy-constructor nor an implicit copy-assignment operator.
  * To remedy this situation we convert the lvalue arguments to rvalues with the `std::move` function.

```cpp
#include <utility>
...
foo(std::move(inner));
...
std::vector<Tracer> v_copy { std::move(v) };
...
sink = std::move(source);
```

* The behavior changes only slightly for the original `main` of the Tracer. Instead of the copy-constructor the move-constructor is used when initializing the `foo` parameter with `inner`. We can observe that the Tracers that have been moved from are still destroyed. We see that in the output at the destructor calls `Tracer destroyed: sink moved to`. We also see that the move operation modifies the contents of the moved object. For example `inner.show()` results in the output `Tracer: inner moved away`, showing that the name of `inner` has been overwritten.
* When disabling copy-elision we can observe an additional move operation (origined at `auto trace = bar(inner)`) when calling `trace.show()`. The output `Tracer: bar` has changed to `Tracer: bar moved`, which indicates one additional move constructions. Before C++17 there was an additional move construction at the initialization of `tracer` to be elided, which is now mandatory.
* For the move-assignment we implemented the operator to swap the names (while in the move-constructor we just add the `" moved away` suffix). We can observe the destruction of the `source` variable at the output `Tracer destroyed: sink moved away`
* The call `std::move(m)` does not have observable behavior. Internally, the `std::move` function is just a cast, which does not have any run-time effect by itself. Therefore, we don't have observable behavior here.

***Important:*** The use of `inner` after it has been moved from, is not allowed in general, until it gets assigned another `Tracer`. This is because its state is unknown. However, it must still be in destructible state.

## Vector Again

When adding Tracers to the vector the copy operations are just replaced by the corresponding move operations. But, there is a change when moving the vector to another vector! This operation does not have any effect on the contained Tracer objects at all! Because they are left in the same memory location no additional move operation happens.

* ***Advanced:*** There might be one peculiar behavior in case our Tracer provides copy AND move operations. If the compiler cannot guarantee that the move operation does not throw an exception it prefers the copy operations when allocating a new array (on resize). In this case copy and move operations on the Tracer are mixed although we work with a moveable type. You can overcome this by declaring the move constructor `noexcept`. The reason for this behavior is exception safety. If a copy operation on an element fails, the resize operation shall not destroy the original vector. If the exception occurs in the middle of a copy operation the newly allocated memory, along with all copied objects, can just be destoryed. If the same happens during a move operation some of the valid objects reside in the old array. Since another exception might happen while moving the objects from the new array back to the old array for restoring the previous state, the vector could end up in a broken state.

## Moving vs. Copying Large Objects
It takes some elements to observe a timing difference between copy and move operations. But even on fast computers when copying or moving 1GB of data the difference should be measurable.
If you cannot see the difference at any size, check whether you have enabled some kind of optimization in your compiler that eliminates the operations you are trying to measure completely.

----


